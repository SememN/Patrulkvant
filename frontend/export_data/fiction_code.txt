const fs = require('fs');
const Az = require('az');
const chalk = require("chalk");
const moment = require("moment");
const ws = require('ws');
const commands = new Map();
const commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));
const Sequelize = require('sequelize');
const readline = require('readline');
const natural = require('natural'),
  porterStemmer = natural.PorterStemmerRu,
  classifier = new natural.BayesClassifier(porterStemmer);

let config = require('./conf.json');
let prefix = config.prefix;
let active = true;
let abc = [
	'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''
];
let vowels = [
	'', '', '', '', '', '', '', '', '', '', '', '', ''
];
let lat = ["I", "V", "X", "L", "C", "D", "M"];
let consonants = vowels.filter(x => abc.includes(x));

const sequelize = new Sequelize('database', 'Alenigma', 'FramoNdbase659', {
	host: 'localhost',
	dialect: 'sqlite',
	logging: false,
	storage: 'database.sqlite',
});

const Dictionary = sequelize.define('Dictionary', {
	word: {
		type: Sequelize.STRING,
		unique: true,
	},
	description: Sequelize.TEXT
});

for (const file of commandFiles) {
	const command = require('./commands/{file}');
	commands.set(command.name, command);
}

function load() {
	Dictionary.sync();
}

load();

console.log('Translator start working');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const bot = { Az, sleep, commands, fs, moment, config, prefix, abc, vowels, consonants, Dictionary, natural, porterStemmer, classifier, rl, active, comm, lat };

while (active) {
	active = false
	comm();
}

function comm () {
rl.question('Please enter the command: ', (answer) => {
	const args = answer.trim().split(/ +/);
	const commandName = args[0].toLowerCase();
	if (!commands.has(commandName)) return;
	const command = commands.get(commandName);
	if (command.args && args.length <= 1) {
		return console.log('К моему сожелению, эта команда требует большей точности, пожалуйста, укажите аргументы');
	}
	command.execute(answer, args, bot);
	rl.close();
});
};

/*friamond.on('message', async (mess) => {
	if (!mess.content.startsWith(prefix) || mess.author.bot) return;
	const cur_user = await Users.findOne({
		where: { iduser: mess.author.id },
	});
	lang(mess);
	if (!cur_user) {
		return mess.channel.send('Невозможно считать биометрию, вы помечены как незаригестрированый пользователь, в выполнении отказано');
	}
	const args = mess.content.slice(prefix.length).trim().split(/ +/);
	const commandName = args[0].toLowerCase();
	if (!commands.has(commandName)) return;
	const command = commands.get(commandName);
	if (command.args && args.length <= 1) {
		return mess.channel.send('К моему сожелению эта команда требует большей точности, пожалуйста, укажите аргументы, {mess.author}');
	}
	if (command.premlv > cur_user.prem) {
		return mess.channel.send('По свединьям из мэрии вы не имеете достаточных полномочий')
    }
	try {
		command.execute(friamond, mess, args, ansvers, bot);
	} catch (error) {
		console.error(error);
		friamond.channels.cache.get('754265735496335451').send('Была получена ошибка при выполнении команды {commandName}: ' + '"' + error + '"');
		mess.reply('Внимание, при выполнении команды была получена ошибка, я всё ещё на бета тестировнии, это нормально, сейчас Аленигма всё починит');
	}
});*/

function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}